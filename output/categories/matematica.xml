<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>En borrador permanente (matemática)</title><link>http://www.juanjoconti.com.ar/</link><description></description><atom:link href="http://www.juanjoconti.com.ar/categories/matematica.xml" type="application/rss+xml" rel="self"></atom:link><language>es</language><lastBuildDate>Tue, 23 Jun 2015 01:31:18 GMT</lastBuildDate><generator>http://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>La soledad de los números primos</title><link>http://www.juanjoconti.com.ar/posts/2011/01/19/la-soledad-de-los-numeros-primos.html</link><dc:creator>Juanjo</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;a href="http://www.juanjoconti.com.ar/wp-content/uploads/2011/01/soledad-numeros-primos.jpg"&gt;&lt;img class="size-full wp-image-3091" title="La soledad de los números primos" src="http://www.juanjoconti.com.ar/wp-content/uploads/2011/01/soledad-numeros-primos.jpg" alt="La soledad de los números primos" width="211" height="320"&gt;&lt;/a&gt;
&lt;p&gt;En las últimas semanas leí la novela &lt;a href="http://www.lecturalia.com/libro/26098/la-soledad-de-los-numeros-primos" target="_blank"&gt;La soledad de los números primos&lt;/a&gt;. Compré el libro atraído por el título y por ser la &lt;em&gt;ópera prima&lt;/em&gt; de un escritor de mi edad, &lt;a href="http://es.wikipedia.org/wiki/Paolo_Giordano" target="_blank"&gt;Paolo Giordano&lt;/a&gt;, italiano.&lt;/p&gt;
&lt;p&gt;El libro habla sobre la soledad, y con saltos de varios años va contando la historia de sus dos personajes.&lt;/p&gt;
&lt;blockquote&gt;&lt;em&gt;En  una clase de primer curso Mattia había estudiado que entre los números  primos hay algunos aún más especiales. Los matemáticos los llaman  números primos gemelos: son parejas de números primos que están juntos, o  mejor dicho, casi juntos, pues entre ellos media siempre un número par  que los impide tocarse de verdad. Números como el 11 y el 13, el 17 y el  19, o el 41 y el 43. Mattia pensaba que Alice y él eran así, dos primos  gemelos, solos y perdidos, juntos pero no lo bastante para tocarse de  verdad.&lt;/em&gt;&lt;/blockquote&gt;

&lt;p&gt;Dos notas: &lt;em&gt;It's not about mathds&lt;/em&gt;. No me gustó el final.&lt;/p&gt;
&lt;p&gt;Una tercera: tengo la película para ver en italiano y creo que va a estar buena.&lt;em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;/div&gt;</description><category>Cosas que leo</category><category>La soledad de los números primos</category><category>libros</category><category>matemática</category><category>Paolo Giordana</category><category>Películas</category><guid>http://www.juanjoconti.com.ar/posts/2011/01/19/la-soledad-de-los-numeros-primos.html</guid><pubDate>Wed, 19 Jan 2011 01:56:23 GMT</pubDate></item><item><title>Los 6 magníficos: divertimentos matemáticos</title><link>http://www.juanjoconti.com.ar/posts/2010/02/25/los-6-magnificos-divertimentos-matematicos.html</link><dc:creator>Juanjo</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Cuando estaba en los primeros años de ingeniería, en la sala de consultas de Materias Básicas (el departamento que reúne las matemáticas, las físicas, las químicas, etc...) vi una calcamonía que me llamó la atención. Planteaba una igualdad entre cinco números: pi, i, e, 0 y 1.&lt;/p&gt;
&lt;p&gt;Ayer, durante una reunión en la misma sala, volví a encontrarla. Seguía en el mismo rincón de un pizarrón, con una punta ajada. No resistí la tentación de fotografiarla y quedármela para siempre. Se las comparto:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.juanjoconti.com.ar/wp-content/uploads/2010/02/Imagen778.jpg"&gt;&lt;img class="aligncenter size-medium wp-image-2158" title="Imagen778" src="http://www.juanjoconti.com.ar/wp-content/uploads/2010/02/Imagen778-225x300.jpg" alt="Imagen778" width="225" height="300"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Una versión, más desprolija, pero en dónde se lee mejor:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.juanjoconti.com.ar/wp-content/uploads/2010/02/Imagen779.jpg"&gt;&lt;img class="aligncenter size-medium wp-image-2160" title="Imagen779" src="http://www.juanjoconti.com.ar/wp-content/uploads/2010/02/Imagen779-225x300.jpg" alt="Imagen779" width="225" height="300"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Una primera pregunta es: ¿Es verdad esa igualdad? Resulta que sí. Lo que me llamó la atención por años es conocido como &lt;a href="http://es.wikipedia.org/wiki/Identidad_de_Euler" target="_blank"&gt;Identidad de Euler&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Pero lo que realmente desvela es que la calcamonía se titulaba &lt;strong&gt;"Los seis magníficos"&lt;/strong&gt; y remata &lt;strong&gt;"¿y el que falta?"&lt;/strong&gt;.¿ Alguien tiene la respuesta?&lt;/p&gt;&lt;/div&gt;</description><category>matemática</category><guid>http://www.juanjoconti.com.ar/posts/2010/02/25/los-6-magnificos-divertimentos-matematicos.html</guid><pubDate>Thu, 25 Feb 2010 18:14:33 GMT</pubDate></item><item><title>Conjuntos en Python</title><link>http://www.juanjoconti.com.ar/posts/2009/11/02/conjuntos-en-python.html</link><dc:creator>Juanjo</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Cuando estaba preparando mi &lt;a href="http://www.juanjoconti.com.ar/2009/10/21/charla-bienvenido-a-python-en-instituto-libre-09" target="_blank"&gt;charla introductoria a Python&lt;/a&gt;, le pasé mis slides a un amigo para que me diga su opinión y una de las cosas que me dijo fue&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;Nunca senti que set sea algo nativo de python, le daria mas importancia a los diccionarios, aunque tal vez tu publico este mas interesado en sets, no lo se.&lt;/blockquote&gt;
&lt;p&gt;Me sorprendió el comentario. Para mi, set es un tipo de dato muy útil y poderoso. En este post voy a intentar hacer una apología de set, el tipo de dato que incorpora Python para representar la noción matemática de conjunto.&lt;/p&gt;
&lt;!--more--&gt;

&lt;h3&gt;Presentación&lt;/h3&gt;

&lt;p&gt;Un objeto set es una colección sin orden de objetos &lt;a href="http://docs.python.org/glossary.html#term-hashable" target="_blank"&gt;&lt;em&gt;hasheables&lt;/em&gt;&lt;/a&gt;. Puede contener objetos de todos los tipos inmutables de Python, pero no los contenedores mutables como listas. También puede contener objetos de clases definidas por el usuario (Los objetos instancias de clases definidas por el usuario son por defecto hasheables.).&lt;/p&gt;
&lt;p&gt;Los conjuntos se pueden crear, por ejemplo, a partir de una lista. Podemos quitar elementos (al azar o uno en concreto) o agregarlos:&lt;/p&gt;
&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; heladera = ['huevo', 'huevo', 'queso', 'leche', 'pera', 'pera', 'pera']

&amp;gt;&amp;gt;&amp;gt; alimentos = set(heladera)

&amp;gt;&amp;gt;&amp;gt; alimentos

set(['queso', 'leche', 'huevo', 'pera'])

&amp;gt;&amp;gt;&amp;gt; alimentos.pop()

'queso'

&amp;gt;&amp;gt;&amp;gt; alimentos.remove('leche')

&amp;gt;&amp;gt;&amp;gt; alimentos

set(['huevo', 'pera'])

&amp;gt;&amp;gt;&amp;gt; alimentos.add('empanada')

&amp;gt;&amp;gt;&amp;gt; alimentos

set(['empanada', 'huevo', 'pera'])&lt;/pre&gt;

&lt;h3&gt;Prueba de pertenencia&lt;/h3&gt;

&lt;p&gt;Otra función muy común y útil es probar la pertenencia de objetos al conjunto:&lt;/p&gt;
&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; 'empanada' in alimentos

True

&amp;gt;&amp;gt;&amp;gt; 'leche' in alimentos

False

&amp;gt;&amp;gt;&amp;gt; 'leche' not in alimentos

True

&lt;/pre&gt;

&lt;h3&gt;Iterar sobre conjuntos&lt;/h3&gt;

&lt;p&gt;Podemos interar sobre conjuntos de la misma forma que lo hacemos sobre listas:&lt;/p&gt;
&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; for a in alimentos:

...     "Debo comer " + a

...

'Debo comer empanada'

'Debo comer huevo'

'Debo comer pera'

&lt;/pre&gt;

&lt;h3&gt;Operaciones sobre conjuntos&lt;/h3&gt;

&lt;p&gt;Los conjuntos en Python soportan las operaciones típicas de conjuntos: restas, intersección, unión y diferencia simétrica (los elementos que están en uno de los conjuntos, pero no en ambos). &lt;a href="http://es.wikipedia.org/wiki/Teor%C3%ADa_de_conjuntos#Operaciones_con_conjuntos"&gt;Repasar operaciones con conjuntos.&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; frutas = set(['banana', 'naranja', 'pera'])

&amp;gt;&amp;gt;&amp;gt; frutas - alimentos

set(['banana', 'naranja'])

&amp;gt;&amp;gt;&amp;gt; alimentos - frutas

set(['huevo', 'empanada'])

&amp;gt;&amp;gt;&amp;gt; frutas &amp;amp; alimentos

set(['pera'])

&amp;gt;&amp;gt;&amp;gt; frutas | alimentos

set(['huevo', 'empanada', 'pera', 'banana', 'naranja'])

&amp;gt;&amp;gt;&amp;gt; frutas ^ alimentos

set(['huevo', 'empanada', 'banana', 'naranja'])&lt;/pre&gt;

&lt;p&gt;También podemos preguntar sin un conjunto es subconjunto de otro. En los ejemplos se utiliza &lt;code&gt;set()&lt;/code&gt;, el conjunto vacío:&lt;/p&gt;
&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; alimentos &amp;lt; set()

False

&amp;gt;&amp;gt;&amp;gt; set() &amp;lt; alimentos

True

&amp;gt;&amp;gt;&amp;gt; set() &amp;gt; alimentos

False

&amp;gt;&amp;gt;&amp;gt; alimentos &amp;lt;= alimentos

True

&lt;/pre&gt;

&lt;h3&gt;El problema de las dos comisiones&lt;/h3&gt;

&lt;p&gt;Este problema está basado en un caso real y lo escuché en la charla &lt;a href="http://ar.pycon.org/2009/conference/proposals/24/" target="_blank"&gt;Escribí menos código, pensá como un (buen) matemático&lt;/a&gt; de Gustavo Carmona (FCEYN - UBA) &lt;sup&gt;&lt;a title="bio" href="http://ar.pycon.org/2009/profile/1d73/"&gt;bio&lt;/a&gt;&lt;/sup&gt; y Matías A Graña (FCEyN - UBA) &lt;sup&gt;&lt;a title="bio" href="http://ar.pycon.org/2009/profile/015c/"&gt;bio&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;Se tienen dos archivos de textos con una lista de e-mails en cada uno. Cada archivo tiene los mails de los funcionarios de una comisión; los archivos no están bien depurados, por lo que pueden contener direcciones repetidas; hay funcionarios trabajando en las dos comisiones. Luego de una reunión en la que trabajaron ambas comisiones, se generó un material que se necesita enviar a todos los participantes. ¿Cómo obtener la lista de destinatarios?&lt;/p&gt;
&lt;pre&gt;archivo1

dir1@mail.com

dir2@mail.com

dir3@mail.com

dir1@mail.com&lt;/pre&gt;

&lt;pre&gt;archivo2

dir21@mail.com

dir23@mail.com

dir3@mail.com

dir1@mail.com&lt;/pre&gt;

&lt;p&gt;Queremos una tercera lista que tenga la primera más la segunda, pero que no estén repetidos.&lt;/p&gt;
&lt;p&gt;El enfoque tradicional que utilizaría un programador para resolver este problema mediante bucles es:&lt;/p&gt;
&lt;pre&gt;def unionlarga(l1, l2):

    l3 = []

    for x in l1:

        if not x in l3:

            l3.append(x)

    for x in l2:

        if not x in l3:

            l3.append(x)

    return l3&lt;/pre&gt;

&lt;p&gt;Supongamos que ya tenemos los archivos leídos y almacenamos el contenidos en listas:&lt;/p&gt;
&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; unionlarga(archivo1, archivo2)

['dir1@mail.com', 'dir2@mail.com', 'dir3@mail.com',

'dir21@mail.com', 'dir23@mail.com']&lt;/pre&gt;

&lt;p&gt;La solución es genérica para cualquier lenguaje. Sin embargo, puede lograr una mejor solución utilizando sets en Python:&lt;/p&gt;
&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; list(set(archivo1) | set(archivo2))

['dir21@mail.com', 'dir3@mail.com', 'dir2@mail.com',

'dir1@mail.com', 'dir23@mail.com']&lt;/pre&gt;

&lt;p&gt;Convertimos ambas listas a conjuntos (con lo que se eliminan los repetidos dentro de las listas), realizamos la unión de ambos conjuntos (con lo que se eliminan los repetidos entre listas y finalmente se convierte el resultado en una nueva lista.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://docs.python.org/library/stdtypes.html#set-types-set-frozenset" target="_blank"&gt;Más sobre conjuntos en la referencia del lenguaje.&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</description><category>Aprendiendo Python</category><category>matemática</category><category>Python</category><guid>http://www.juanjoconti.com.ar/posts/2009/11/02/conjuntos-en-python.html</guid><pubDate>Mon, 02 Nov 2009 00:58:30 GMT</pubDate></item><item><title>All you need is love!</title><link>http://www.juanjoconti.com.ar/posts/2006/10/07/all-you-need-is-love.html</link><dc:creator>Juanjo</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Desde el etorno gráfico de tu GNU/Linux abrí una terminal (gnome-terminal, Konsole, Eterm u otra). Con tu editor preferido (vi, emacs, gedit u otro) creá el archivo &lt;code&gt;love&lt;/code&gt; con este contenido:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;pre&gt;plot a*(1-sin(t))
&lt;p&gt;a = a - 2&lt;/p&gt;
&lt;p&gt;pause 1&lt;/p&gt;
&lt;p&gt;if(a == 0) a = 16&lt;/p&gt;
&lt;p&gt;reread&lt;/p&gt;
&lt;/pre&gt;

&lt;p&gt;Desde la terminal ejecutá el comando &lt;code&gt;gnuplot&lt;/code&gt; y allí:&lt;/p&gt;
&lt;pre&gt;gnuplot&amp;gt; set polar

        dummy variable is t for curves

gnuplot&amp;gt; set xrange[-25:25]; set yrange[-35:5]

gnuplot&amp;gt; a = 16

gnuplot&amp;gt; set title "All you need is love"

gnuplot&amp;gt; load 'love'

&lt;/pre&gt;

&lt;p&gt;Done! All you need is love!.. and gnuplot! :)&lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;&lt;a href="http://www.gnuplot.info"&gt;Gnuplot&lt;/a&gt; es un potente &lt;a href="http://www.gnu.org/philosophy/free-sw.es.html"&gt;Software Libre&lt;/a&gt; que permite graficar funciones matemáticas tanto en 2 como en 3 dimenciones.&lt;/p&gt;
&lt;p&gt;a*(1-sin(t)) es una función matemática en coordenadas polares que se denomina cardioide por su forma de corazón.&lt;/p&gt;
&lt;p&gt;Este pequeño ejemplo ilustra como utilizar esta herramienta para crear animaciones en base a la parametrización de funciones matemáticas que nos permitan observar comportamientos según cambian los valores de los parámetros.&lt;/p&gt;&lt;/div&gt;</description><category>General</category><category>gnuplot</category><category>matemática</category><guid>http://www.juanjoconti.com.ar/posts/2006/10/07/all-you-need-is-love.html</guid><pubDate>Sat, 07 Oct 2006 13:54:32 GMT</pubDate></item><item><title>Fermat vs. Pythagoras mejorado</title><link>http://www.juanjoconti.com.ar/posts/2006/05/30/fermat-vs-pythagoras-mejorado.html</link><dc:creator>Juanjo</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Logré bajar la complejidad de &lt;a href="http://firebirds.com.ar/~juanjo/wordpress/2006/05/29/fermat-vs-pythagoras/"&gt;mi solución de un orden cúbico&lt;/a&gt; a un orden cuadrático, la diferencia en cuanto a tiempo de ejecución requerido es sorprendente:&lt;/p&gt;
&lt;p&gt;&lt;img id="image88" src="http://firebirds.com.ar/%7Ejuanjo/wordpress/wp-content/uploads/2006/05/pytagoras2.png" alt="comparacion de 3 soluciones"&gt;&lt;/p&gt;
&lt;p&gt;Pero todavía no e suficiente, con un N igual a 10000 la respuesta se obtiene luego de 10 minutos (en mi computadora de 700 Mhz).&lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;En esta solución ya no uso la función &lt;code&gt;pythagoras(x,y,z)&lt;/code&gt;. Solo hay 2 ciclos &lt;code&gt;for&lt;/code&gt; anidados y el valor de z se calcula como &lt;code&gt;z = sqrt( pow(x,2) + pow(y,2) )&lt;/code&gt;. Si z es entero, se tiene un triplete válido y solo falta verificar si x,y,z son primos relativos.&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;pre&gt;def is_int(i):
&lt;pre class="code literal-block"&gt;return i == int(i)
&lt;/pre&gt;


&lt;p&gt;def solv106f(N):&lt;/p&gt;
&lt;pre class="code literal-block"&gt;miembros = []

tripletes_rprim = 0

for x in range(1,N-1):

    for y in range(x+1,N):

        z = sqrt( pow(x,2) + pow(y,2) )

        if (is_int(z) and z &amp;amp;lt;= N):

            for a in [x,y,z]:

                if a not in miembros:

                    miembros.append(a)

            if (rprim(x,y,z)):

                tripletes_rprim +=1



no_miembros = N - len(miembros)

return N, tripletes_rprim, no_miembros
&lt;/pre&gt;


&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;</description><category>Aprendiendo Python</category><category>matemática</category><category>Problemas</category><category>Python</category><guid>http://www.juanjoconti.com.ar/posts/2006/05/30/fermat-vs-pythagoras-mejorado.html</guid><pubDate>Tue, 30 May 2006 02:16:41 GMT</pubDate></item><item><title>Fermat vs. Pythagoras</title><link>http://www.juanjoconti.com.ar/posts/2006/05/29/fermat-vs-pythagoras.html</link><dc:creator>Juanjo</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Esta es mi solución al problema número 6 de una &lt;a title="problemset" href="http://acm.uva.es/problemset/" target="_blank"&gt;larga lista de problemas de programación&lt;/a&gt;. A pesar de que, como estudiante de Ingeniería, pasé los últimos 3 años y medio estudiando distintas formas de las matemáticas, no conocí el &lt;a title="Último Teorema de Fermat" href="http://es.wikipedia.org/wiki/%C3%9Altimo_teorema_de_Fermat" target="_blank"&gt;Último Teorema de Fermat&lt;/a&gt; hasta que mi amigo Joel, estudiante de Filosofía, me lo comentó.&lt;/p&gt;
&lt;p&gt;El problema en realidad no tiene mucho que ver con Fermat, pero sí con Pitágoras: dado un valor N, hay que encontrar &lt;em&gt;cuántos&lt;/em&gt; tripletes x,y,z satisfacen &lt;strong&gt;x² + y² = z² &lt;/strong&gt;tales que&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;ul&gt;
&lt;/ul&gt;&lt;pre class="code literal-block"&gt;&lt;span class="nt"&gt;&amp;lt;li&amp;gt;&lt;/span&gt;x,y,z sean menores o iguales a N&lt;span class="nt"&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;

&lt;span class="nt"&gt;&amp;lt;li&amp;gt;&lt;/span&gt;x,y,z sean primos relativos (es decir que 1 es su único divisor común)&lt;span class="nt"&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;

&lt;span class="nt"&gt;&amp;lt;li&amp;gt;&lt;/span&gt;x &lt;span class="ni"&gt;&amp;amp;lt;&lt;/span&gt; y &lt;span class="ni"&gt;&amp;amp;lt;&lt;/span&gt; z&lt;span class="nt"&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
&lt;/pre&gt;




&lt;p&gt;Además hay que encontrar &lt;em&gt;cuántos&lt;/em&gt; números mayores que 0 y menores o iguales a N no pertenecen a ninguno de los tripletes (no solo a los tripletes de primos relativos).&lt;/p&gt;
&lt;p&gt;El enunciado original &lt;a href="http://acm.uva.es/p/v1/106.html"&gt;aquí&lt;/a&gt;.&lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;Una posibilidad sería explorar exasutivamente todas las combinaciones de números x,y,z menores o iguales a N, y para cada uno verificar si cumplen las características pedidas. Pero esto sería de altísima complejidad, sería de orden cúbico. Hay que pensar una mejor solución.&lt;/p&gt;
&lt;p&gt;Empecemos con una función que dado 3 valores x,y,z me diga si satisfacen el Teorema de Pitágoras:&lt;/p&gt;
&lt;p&gt;&lt;code&gt; &lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;from math import pow



def pythagoras(x,y,z):

    return (pow(x,2)+pow(y,2) == pow(z,2))

&lt;/pre&gt;

&lt;pre&gt;

&amp;gt;&amp;gt;&amp;gt; pythagoras(3,4,5)

True

&amp;gt;&amp;gt;&amp;gt; pythagoras(1,1,1)

False

&amp;gt;&amp;gt;&amp;gt; pythagoras()

True

&lt;/pre&gt;

&lt;p&gt;También necesito una función, que dado 3 valores x,y,z me diga sin son primos relativos entre sí:&lt;/p&gt;
&lt;p&gt;&lt;code&gt; &lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;def mcd(a,b): # algoritmo de euclides

    if (a == b): return a

    elif (a &amp;lt; b): a,b = b,a # a es el más grande

    while(b != 0):

        r = a % b

        a = b

        b = r

        return a



def rprim(x,y,z):

    return (mcd(mcd(x,y),z) == 1)

&lt;/pre&gt;

&lt;p&gt;La solución que explora todas las combinaciones de 3 números constaría de 3 ciclos &lt;code&gt;for&lt;/code&gt; anidados y en el curerpo del más profundo se haría las preguntas pertitenes a la resolución del problema: ¿ese triplete satisface el teorema de pitagoras? ¿son primos relativos? ¿x&amp;lt;y&amp;lt;z?&lt;/p&gt;
&lt;pre&gt;for(x=1;x=&amp;lt;N;x++)

    for(y=1;y=&amp;lt;N;y++)

        for(z=1;z=&amp;lt;N;z++)

            # ¿...?

&lt;/pre&gt;

&lt;p&gt;Una de las condiciones es que x&amp;lt;y&amp;lt;z, esto permite una redefinición tal que NO se exploren todas las combinaciones de 3 números menores que N sino solo las combinaciones que cumplen con esta restricción:&lt;/p&gt;
&lt;pre&gt;for(x=1;x=&amp;lt;N-2;x++)

    for(y=x+1;y=&amp;lt;N-1;y++)

        for(z=y+1;z=&amp;lt;N;z++)

            # ¿..?

&lt;/pre&gt;

&lt;p&gt;¿Esta solución es buena o no es mucho mejor a una en la que todos los ciclos &lt;code&gt;for&lt;/code&gt; vayan de 1 a N y por cada uno se pregunte si x,y,z?&lt;/p&gt;
&lt;p&gt;En el archivo &lt;a href="http://firebirds.com.ar/~juanjo/wordpress/files/pp/pythagoras.py.html"&gt;pythagoras.py&lt;/a&gt; están definidas dos funciones: &lt;code&gt;solv106s(N)&lt;/code&gt;, basada en la primera aproximación y &lt;code&gt;solv106(N)&lt;/code&gt; que &lt;em&gt;espera&lt;/em&gt; ser mejor.&lt;/p&gt;
&lt;p&gt;Este programita sirve para medir el tiempo de las dos ejecuciones y compararlos.&lt;/p&gt;
&lt;pre&gt;import timing



def test(N=1000):

    timing.start()

    solv106s(N)

    timing.finish()

    print "la primer solución tardo " + str(timing.seconds()) + " segundos"

    timing.start()

    solv106(N)

    timing.finish()

    print "la segunda solución tardo " + str(timing.seconds()) + " segundos"

&lt;/pre&gt;

&lt;p&gt;Hago una prueba con un valor relativamente grande, N=1000 el valor por defecto:&lt;/p&gt;
&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; test()

la primer solución tardo  1879 segundos

la segunda solución tardo 1561 segundos

&lt;/pre&gt;

&lt;p&gt;31 minutos contra 26 minutos.. no me parece una diferencia muy grande. Nota: mi máquina es un AMD K6 II de 700 Mhz.&lt;/p&gt;
&lt;p&gt;Esta gráfica compara las dos soluciones luego de haberlas probado con diferentes valores de N, obtenido unos puntos e interpolar una curva representativa:&lt;/p&gt;
&lt;p&gt;&lt;img id="image87" title="comparacion" src="http://firebirds.com.ar/%7Ejuanjo/wordpress/wp-content/uploads/2006/05/comparacion106.png" alt="comparacion" align="middle"&gt;&lt;/p&gt;
&lt;p&gt;mmm, hay que pensar una mejor solución.&lt;/p&gt;&lt;/div&gt;</description><category>Aprendiendo Python</category><category>matemática</category><category>Problemas</category><category>Python</category><guid>http://www.juanjoconti.com.ar/posts/2006/05/29/fermat-vs-pythagoras.html</guid><pubDate>Mon, 29 May 2006 01:30:56 GMT</pubDate></item><item><title>3n+1</title><link>http://www.juanjoconti.com.ar/posts/2006/05/25/3n1.html</link><dc:creator>Juanjo</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;a href="http://www.acm.org"&gt;ACM&lt;/a&gt; (&lt;em&gt;Association for Computing Machinery&lt;/em&gt;) organiza unas competencias de programación llamadas &lt;a href="http://icpc.baylor.edu/icpc/"&gt;ICPC&lt;/a&gt; (&lt;em&gt;International Collegiate Programming Contest&lt;/em&gt;). En esta dirección hay muchos problemas de las competencias: &lt;a href="http://acm.uva.es/problemset/"&gt;http://acm.uva.es/problemset/&lt;/a&gt;.
&lt;p&gt;Este es el enunciado del primer problema de la guía: &lt;a href="http://acm.uva.es/p/v1/100.html"&gt;http://acm.uva.es/p/v1/100.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;El fin de semana hice esta solución:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(nota: los lenguajes soportados por las competencias son C y Java, mi solución está escrita en Python por que me resulta más ágil. De todas formas importa más el algoritmo que el lenguaje.)&lt;/em&gt;&lt;/p&gt;
&lt;!--more--&gt;

&lt;pre&gt;def odd(n):

    return not (n%2 == 0)

&lt;/pre&gt;

&lt;pre&gt;def tnu(n=1):

    print n

    if (n == 1): return

    elif (odd(n)): n = 3*n+1

    else: n = n/2

    tnu(n) # la recursividad por la cola es evitable

&lt;/pre&gt;

&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; tnu(22)

22

11

34

17

52

26

13

40

20

10

5

16

8

4

2

1

&lt;/pre&gt;

&lt;p&gt;La longitud del ciclo para un n dado es la cantidad de valores que la función tnu() develve (incluido el 1 final)&lt;/p&gt;
&lt;p&gt;El problema pide leer un archivo con pares i,j y para cada par devolver la mayor longitud de ciclo para todos los enteres enter i y j incluyendo a i y a j.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Solución Exaustiva&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Una solución exaustiva podría consistir en calcular para cada par i,j todos las longitudes de ciclo asociadas y devolver la mayor.&lt;/p&gt;
&lt;p&gt;Redefino tnu para que en lugar de imprimir los sucesivos valores de n devulva una lista con los valores, el segundo argumento de la función es una lista vacía.&lt;/p&gt;
&lt;pre&gt;def tnu(n,l):

    #print n

    l.append(n)

    if (n == 1): return l

    elif (odd(n)): n = 3*n+1

    else: n = n/2

    return tnu(n,l) # la recursividad por la cola es evitable

&lt;/pre&gt;

&lt;p&gt;Suponiendo que ya se leyeron los pares del archivo correspondiente y se tienen en una lista llamada pairs:&lt;/p&gt;
&lt;pre&gt;def solv1(pairs):

    for i,j in pairs:

        maxc = 0

        for n in range(i,j+1):

            maxc = max(len(tnu(n,[])),maxc)

        print i, j, maxc

&lt;/pre&gt;

&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; pairs = [(1,10),(88,123),(7,1),(55,455),(10000,10003)]

&amp;gt;&amp;gt;&amp;gt; solv1(pairs)

1 10 20

88 123 119

7 1 0

55 455 144

10000 10003 180

&amp;gt;&amp;gt;&amp;gt; pairs = [(1,10),(100,200),(201,210),(900,1000)]

&amp;gt;&amp;gt;&amp;gt; solv1(pairs)

1 10 20

100 200 125

201 210 89

900 1000 174

&lt;/pre&gt;

&lt;p&gt;Bien, esta solución ANDA, pero no es óptima. De hecho probablemente sea la solución menos eficiente :-) la de la fuerza bruta.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Solución Dinámica&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;La idea es almacenar los resultados ya calculados para no tener que hacerlos una y otra vez. Si se pide la máxima longitud de ciclo (mlc) enter 100 y 200 y obtengo 125 y luego se pide la máxima longitud de ciclo enter 1 y 300, voy a calcular la mlc para el par 1,100, luego lo haré para 200,300 y luego compararé los resultados con 125 quedándome con el mayor de los 3.&lt;/p&gt;
&lt;p&gt;Pero.. que pasa si ya he calculado la mlc para los valores entre 2 y 99?&lt;/p&gt;
&lt;pre&gt;def solv1din(pairs,dic):

    for i,j in pairs:

        maxc = f_maxc(i,j,dic)

        print i, j, maxc

        dic[i,j]=maxc

&lt;/pre&gt;

&lt;pre&gt;def f_maxc(i,j,dic):

    wide = 0

    for a,b in dic.keys():

        if a == i and b == j: return dic[a,b]

        if (i&amp;lt;=a and b&amp;lt;=j and b-a &amp;gt; wide):

            f,g = a,b

            wide = b-a

    if (wide == 0): #ningún rango del diccionario estaba dentro de i,j

        maxc = 0

        for n in range(i,j+1):

            maxc = max(len(tnu(n,[])),maxc)

        return maxc

    else:

        return max(f_maxc(i,f,dic),dic[f,g],f_maxc(g,j,dic))

&lt;/pre&gt;

&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; solv1din(pairs,{})

1 10 20

100 200 125

201 210 89

900 1000 174

&lt;/pre&gt;

&lt;p&gt;Una versión no recursiva de tnu podría ser algo como esto:&lt;/p&gt;
&lt;pre&gt;def tnu(n):

    l = []

    while(n != 1):

        l.append(n)

        if (odd(n)): n = 3*n+1

        else: n = n/2

    l.append(1)

    return l

&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Download&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;

    &lt;li&gt;Una implementación completa que resuelve el problema: &lt;a href="http://firebirds.com.ar/~juanjo/wordpress/files/pp/3n+1.py.html"&gt;3n+1.py&lt;/a&gt;&lt;/li&gt;

    &lt;li&gt;Un archivo de entrada de ejemplo: &lt;a href="http://firebirds.com.ar/~juanjo/wordpress/files/pp/input100.txt"&gt;input100.txt&lt;/a&gt;&lt;/li&gt;

&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Ejemplo de uso&lt;/strong&gt;&lt;/p&gt;
&lt;pre lang="bash"&gt;juanjo@sarge:~/problemas$ ./3n+1.py input100.txt

1 10 20

100 200 125

201 210 89

900 1000 174

88 123 119

7 1 0

55 455 144

10000 10003 180

&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;&lt;/div&gt;</description><category>Aprendiendo Python</category><category>matemática</category><category>Problemas</category><category>Python</category><guid>http://www.juanjoconti.com.ar/posts/2006/05/25/3n1.html</guid><pubDate>Thu, 25 May 2006 17:44:34 GMT</pubDate></item><item><title>Quiero obtener el mínimo cuadrado perfecto mayor a n</title><link>http://www.juanjoconti.com.ar/posts/2006/03/31/quiero-obtener-el-minimo-cuadrado-perfecto-mayor-a-n.html</link><dc:creator>Juanjo</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Programando mi generador de constelaciones llegué a este problema:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Obtener el mínimo cuadrado perfecto mayor a n (con n &lt;/em&gt;&lt;/p&gt;
&lt;p&gt;¿Cómo hubiese sido la forma iterativa de hacerlo?&lt;/p&gt;
&lt;pre&gt;

&amp;gt;&amp;gt;&amp;gt; def min_perf_sqrt(n):

...    i = s = 1

...    while (s 

Este es mi one-liner hecho en python con un toque de programación funcional:

&lt;pre&gt;

min(filter(lambda i: i &amp;gt; n, map(lambda j: j*j, range(13))))

&lt;/pre&gt;

&lt;p&gt;Mmm probablemente la versión iterativa sea más eficiente.. programadores? comentarios?&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;</description><category>Aprendiendo Python</category><category>matemática</category><category>Python</category><guid>http://www.juanjoconti.com.ar/posts/2006/03/31/quiero-obtener-el-minimo-cuadrado-perfecto-mayor-a-n.html</guid><pubDate>Fri, 31 Mar 2006 02:07:36 GMT</pubDate></item><item><title>gnuplot</title><link>http://www.juanjoconti.com.ar/posts/2006/01/10/gnuplot.html</link><dc:creator>Juanjo</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;El año pasado escribí una guía sobre este programa para el proyecto &lt;a href="http://www.gleducar.org.ar"&gt;Gleducar&lt;/a&gt;, en la introducción decía algo que cuando lo leí reien me gustó:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;Los autores iniciales de &lt;a href="http://www.gnuplot.info"&gt;gnuplot &lt;/a&gt;son Thomas Williams y Colin Kelly, quienes decidieron crear un programa que les permitiera visualizar las ecuaciones matemáticas de las clases de electromagnetismo y ecuaciones diferenciales. Ellos eran estudiantes igual que ustedes, se encontraron con un problema (ya que no contaban con una herramienta como esta) y le dieron una solución. Gracias a su generosidad, hoy está disponible para todos.&lt;/blockquote&gt;
&lt;p&gt;Lo encontré en la web con el formato de media wiki (el sistema que usan en &lt;a href="http://www.wikipedia.org"&gt;Wikipedia&lt;/a&gt;) -- muy lindo, gracias a quien lo haya pasado!! les dejo el link por si quieren leerlo &lt;a href="http://wiki.gleducar.org.ar/wiki/index.php/Manual_GNUPlot"&gt;http://wiki.gleducar.org.ar/wiki/index.php/Manual_GNUPlot&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</description><category>gnuplot</category><category>matemática</category><category>Software Libre</category><guid>http://www.juanjoconti.com.ar/posts/2006/01/10/gnuplot.html</guid><pubDate>Tue, 10 Jan 2006 15:41:18 GMT</pubDate></item><item><title>tartaglia.py</title><link>http://www.juanjoconti.com.ar/posts/2006/01/08/tartagliapy.html</link><dc:creator>Juanjo</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;La primer vez que escribí un código para el triángulo de tartaglia lo hice en Prolog y se me ocurrió que podría hacerlo en Python para practivar, lo hice de 4 formas distintas: &lt;a href="http://firebirds.com.ar/~juanjo/wordpress/files/python/tartaglia.py.html"&gt;tartaglia.py&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</description><category>Aprendiendo Python</category><category>matemática</category><category>Python</category><guid>http://www.juanjoconti.com.ar/posts/2006/01/08/tartagliapy.html</guid><pubDate>Sun, 08 Jan 2006 19:13:47 GMT</pubDate></item></channel></rss>